<!DOCTYPE html>
<html>
<head>
  <title>Store Locator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial;
      display: flex;
      height: 100vh;
      overflow: hidden;
      width:100%;
    }

    #sidebar {
      width: 300px;
      background: #f4f4f4;
      padding: 10px 30px 10px 10px;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto;
    }

    #map {
      flex: 1;
    }

    #searchInput, #storeSelect {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }

    .store-item {
      padding: 8px;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
    }

    .store-item:hover {
      background-color: #e2e2e2;
    }

    h2 {
      margin-top: 0;
    }

    /* --- Responsive CSS --- */

  /* Hide the dropdown by default (desktop view) */
  #storeSelect {
    display: none;
  }

  /* Media query for Mobile View */
  @media (max-width: 768px) {

    body{
      display: inline-block;
    }
    

    #sidebar {
      width: 100%; /* Sidebar takes full width */
      height: fit-content; /* Sidebar height adjusts to content */
      padding: 10px; /* Adjust padding for smaller screens */
      box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Adjust shadow for bottom */
      overflow-y: visible; /* Allow scrolling if needed, but for small content, visible is fine */
    }

    #searchInput,
    #storeList {
      display: none; /* Hide search box and store list on mobile */
    }

    #storeSelect {
      display: block; /* Show dropdown on mobile */
      width:95%;
      position: relative;
      z-index:9999;
    }

    #map {
      height: 100vh; /* Map takes remaining vertical space */
    }
  }

  /* Adjustments for even smaller screens if necessary, e.g., phones */
  @media (max-width: 480px) {
      #sidebar {
          padding: 8px; /* Slightly less padding for very small screens */
      }
      #searchInput, #storeSelect {
          font-size: 14px; /* Smaller font size for inputs */
          padding: 8px;
      }
  }
  </style>
</head>
<body>

  <div id="sidebar">
    <h2>Store Locator</h2>
    <input type="text" id="searchInput" placeholder="Search store name, city, or address...">
    <select id="storeSelect">
        <option value="">Select a Store</option>
    </select>
    <div id="storeList"></div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>

    const map = L.map('map').setView([23.185884, 79.974380], 6);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    let allMarkers = [];
    let storeData = []; // This will hold the parsed CSV data

    function addMarker(name, address, city, lat, lng, index, contact) {
      const marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup(`<strong>${name}</strong><br>${address}<br>${contact}`);
      marker.meta = { name, address, city, index, contact }; // Store original data for easy lookup
      allMarkers.push(marker);
      return marker; // Return the marker so we can use it immediately if needed
    }

    function updateStoreList(filteredStores) {
      const listEl = document.getElementById('storeList');
      listEl.innerHTML = "";

      if (filteredStores.length === 0) {
        listEl.innerHTML = "<p>No matching stores found.</p>";
        return;
      }

      filteredStores.forEach(store => {
        const div = document.createElement("div");
        div.className = "store-item";
        div.textContent = `${toTitleCase(store.name)} (${toTitleCase(store.city)}), Contact - ${store.contact}`;
        div.addEventListener("click", () => {
          // Find the marker using the store's index
          const marker = allMarkers[store.index];
          if (marker) {
            map.setView(marker.getLatLng(), 14);
            marker.openPopup();
          }
        });
        listEl.appendChild(div);
      });
    }

    function populateStoreDropdown(stores) {
      const selectEl = document.getElementById('storeSelect');
      selectEl.innerHTML = '<option value="">Select a Store</option>'; // Clear existing options and add default

      stores.forEach((store, index) => {
        const option = document.createElement('option');
        option.value = index; // Use the original index to link to the marker
        option.textContent = `${toTitleCase(store.name)} (${toTitleCase(store.city)})`;
        selectEl.appendChild(option);
      });
    }

    function filterStores(query) {
      const lowerQuery = query.toLowerCase();
      let filteredStores = [];

      allMarkers.forEach(marker => {
        const store = marker.meta; // Access the original store data from marker.meta
        const match = store.name.toLowerCase().includes(lowerQuery) ||
                      store.address.toLowerCase().includes(lowerQuery) ||
                      store.city.toLowerCase().includes(lowerQuery);

        if (match) {
          if (!map.hasLayer(marker)) {
            marker.addTo(map);
          }
          filteredStores.push(store); // Push the original store data for sorting and list update
        } else {
          if (map.hasLayer(marker)) {
            map.removeLayer(marker);
          }
        }
      });

      // Sort the filtered stores by name
      filteredStores.sort((a, b) => a.name.localeCompare(b.name));

      // Update the store list (sidebar)
      updateStoreList(filteredStores);

      // No need to update the dropdown based on search, it always shows all stores
      // If you want the dropdown to also filter, we'd need more logic here.

      // Zoom to bounds of visible markers
      const visibleMarkers = allMarkers.filter(marker => map.hasLayer(marker));
      if (visibleMarkers.length > 0) {
        const group = L.featureGroup(visibleMarkers);
        map.fitBounds(group.getBounds().pad(0.2));
      } else {
        map.setView([23.185884, 79.974380], 6); // Reset view if no markers are visible
      }
    }

    document.getElementById('searchInput').addEventListener('input', e => {
      filterStores(e.target.value);
    });

    document.getElementById('storeSelect').addEventListener('change', e => {
      const selectedIndex = parseInt(e.target.value);
      if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < allMarkers.length) {
        const marker = allMarkers[selectedIndex];

        // Fly to the selected marker's location and open its popup
        map.flyTo(marker.getLatLng(), 16, { animate: true, duration: 1.5 }); // Adjust zoom level (e.g., 16, 17, 18) as needed
        marker.openPopup();

        // OPTIONAL: Clear the search input if you want
        document.getElementById('searchInput').value = '';

        // IMPORTANT: DO NOT call filterStores('') here if you want to keep the map focused
        // on the single selected marker. If you call it, it will re-filter all markers
        // and zoom out to fit them.

        // If you want the sidebar list to also reset to "all stores" after selection
        // WITHOUT affecting the map's zoom/view, you'd need a separate function
        // that updates the list without calling map.fitBounds.
        // For now, let's just remove the problematic line.

        // If the sidebar list should *only* show the selected store, you'd modify updateStoreList
        // to accept a single store or a specific filter after selection.
      }
      // Optional: Reset the dropdown to "Select a Store" after selection if you want.
      // e.target.value = '';
    });

    // Load CSV
    fetch("https://docs.google.com/spreadsheets/d/e/2PACX-1vQhIU7lqfi5iHWY1kDwo57TyyHMEKa0tWctb2Hz1clBIlWzMaw3qJLuJ_AjBRHrb4ev2iS4P0FwhT2x/pub?output=csv")
      .then(res => res.text())
      .then(csv => {
        const data = Papa.parse(csv, { header: true }).data;

        data.forEach((row, index) => {
          // Adjust column names if they are different in your CSV
          const name = row['Store Name'] || row['Name'] || row[0];
          const address = row['Address'] || row[1];
          const city = row['City'] || row[2];
          const lat = parseFloat(row['Latitude'] || row[3]);
          const lng = parseFloat(row['Longitude'] || row[4]);
          const contact = row['Contact'] || row[5]; // Keep contact as string if it can contain non-numeric chars

          if (!isNaN(lat) && !isNaN(lng)) {
            // Push the full store data, including the original index from the CSV iteration
            storeData.push({ name, address, city, lat, lng, index, contact });
            addMarker(name, address, city, lat, lng, index, contact);
          }
        });

        // Sort the *initial* storeData by name before populating lists
        storeData.sort((a, b) => a.name.localeCompare(b.name));

        // Initial populate of dropdown and list
        populateStoreDropdown(storeData);
        updateStoreList(storeData);
      });

    function toTitleCase(str) {
      if (!str) return ''; // Handle null or undefined strings
      return str
        .toLowerCase()
        .split(/[\s-_]+/)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
  </script>
</body>
</html>
